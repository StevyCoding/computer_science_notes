- [[#Summary of Creating and Manipulating Strings|Summary of Creating and Manipulating Strings]]
	- [[#Summary of Creating and Manipulating Strings#String Methods|String Methods]]
	- [[#Summary of Creating and Manipulating Strings#Example Usage|Example Usage]]
	- [[#Summary of Creating and Manipulating Strings#Summary of Formatting Values in Java|Summary of Formatting Values in Java]]
		- [[#Summary of Formatting Values in Java#Example Usage|Example Usage]]
		- [[#Summary of Formatting Values in Java#Using Flags|Using Flags]]
		- [[#Summary of Formatting Values in Java#Examples of Formatting with Flags|Examples of Formatting with Flags]]
	- [[#Summary of Creating and Manipulating Strings#Using the StringBuilder Class|Using the StringBuilder Class]]
	- [[#Summary of Creating and Manipulating Strings#Summary of Creating a StringBuilder|Summary of Creating a StringBuilder]]
	- [[#Summary of Creating and Manipulating Strings#Summary of Comparing `equals()` and `==` in Java|Summary of Comparing `equals()` and `==` in Java]]
		- [[#Summary of Comparing `equals()` and `==` in Java#Understanding `==` with Objects|Understanding `==` with Objects]]
		- [[#Summary of Comparing `equals()` and `==` in Java#The `equals()` Method|The `equals()` Method]]
		- [[#Summary of Comparing `equals()` and `==` in Java#Compilation Errors with Different Types|Compilation Errors with Different Types]]
		- [[#Summary of Comparing `equals()` and `==` in Java#The String Pool|The String Pool]]
		- [[#Summary of Comparing `equals()` and `==` in Java#Runtime String Creation|Runtime String Creation]]
		- [[#Summary of Comparing `equals()` and `==` in Java#Using `+=` with Strings|Using `+=` with Strings]]
		- [[#Summary of Comparing `equals()` and `==` in Java#Creating New Strings with `new`|Creating New Strings with `new`]]
		- [[#Summary of Comparing `equals()` and `==` in Java#Interning Strings|Interning Strings]]
		- [[#Summary of Comparing `equals()` and `==` in Java#Examples with Compile-Time Constants|Examples with Compile-Time Constants]]
	- [[#Summary of Creating and Manipulating Strings#Conclusion|Conclusion]]
	- [[#Summary of Creating and Manipulating Strings#The String Pool|The String Pool]]
	- [[#Summary of Creating and Manipulating Strings#Example: String Equality|Example: String Equality]]
	- [[#Summary of Creating and Manipulating Strings#String Concatenation and New Objects|String Concatenation and New Objects]]
	- [[#Summary of Creating and Manipulating Strings#The `intern()` Method|The `intern()` Method]]
	- [[#Summary of Creating and Manipulating Strings#Example: Complex String Pooling Scenario|Example: Complex String Pooling Scenario]]
	- [[#Summary of Creating and Manipulating Strings#Key Takeaways:|Key Takeaways:]]
- [[#Understanding Arrays in Java|Understanding Arrays in Java]]
	- [[#Understanding Arrays in Java#Creating and Using Arrays with Reference Variables|Creating and Using Arrays with Reference Variables]]
	- [[#Understanding Arrays in Java#Creating and Using Arrays with Reference Variables|Creating and Using Arrays with Reference Variables]]
	- [[#Understanding Arrays in Java#Sorting, Searching, Comparing Arrays in Java|Sorting, Searching, Comparing Arrays in Java]]
		- [[#Sorting, Searching, Comparing Arrays in Java#Sorting Arrays|Sorting Arrays]]
		- [[#Sorting, Searching, Comparing Arrays in Java#Searching Arrays|Searching Arrays]]
		- [[#Sorting, Searching, Comparing Arrays in Java#Comparing Arrays|Comparing Arrays]]
		- [[#Sorting, Searching, Comparing Arrays in Java#Using Mismatch|Using Mismatch]]
		- [[#Sorting, Searching, Comparing Arrays in Java#Using Methods with Varargs|Using Methods with Varargs]]
	- [[#Understanding Arrays in Java#Multidimensional Arrays|Multidimensional Arrays]]
		- [[#Multidimensional Arrays#Creating Multidimensional Arrays|Creating Multidimensional Arrays]]
		- [[#Multidimensional Arrays#Asymmetric Multidimensional Arrays|Asymmetric Multidimensional Arrays]]
		- [[#Multidimensional Arrays#Using Multidimensional Arrays|Using Multidimensional Arrays]]
- [[#Java Math Class|Java Math Class]]
	- [[#Java Math Class#Common Methods|Common Methods]]
	- [[#Java Math Class#Important Notes|Important Notes]]
- [[#Working with Dates and Times in Java|Working with Dates and Times in Java]]
	- [[#Working with Dates and Times in Java#Method in LocalDate, LoacalTime, LocalDateTime, ZonedDateTime|Method in LocalDate, LoacalTime, LocalDateTime, ZonedDateTime]]
	- [[#Working with Dates and Times in Java#Working with periods|Working with periods]]
	- [[#Working with Dates and Times in Java#Working with Duration|Working with Duration]]
	- [[#Working with Dates and Times in Java#Working with Instants|Working with Instants]]

## Summary of Creating and Manipulating Strings

The String class is essential in Java, forming the basis for handling text. A string is defined as a sequence of characters, as shown in the example:

```java
String name = "Fluffy";
```

In Java, strings can be created using string literals or with the `new` keyword, as in:

```java
String name = new String("Fluffy");
```

Both methods create a reference variable pointing to the same String object, but the String class is unique as it does not require `new` for instantiation. Additionally, strings can be created using text blocks, such as:

```java
String name = """
              Fluffy""";
```

Strings implement the `CharSequence` interface, which encompasses several classes, including `String` and `StringBuilder`. The section also covers concatenation, common methods for string manipulation, and method chaining for cleaner code.

In Java, the `String` class provides a rich set of methods for manipulating strings. Below is a list of commonly used methods available in the `String` class, along with brief descriptions of each:

### String Methods

1. **charAt(int index)**: Returns the character at the specified index.
   
2. **compareTo(String anotherString)**: Compares two strings lexicographically.
   
3. **compareToIgnoreCase(String anotherString)**: Compares two strings lexicographically, ignoring case differences.
   
4. **concat(String str)**: Concatenates the specified string to the end of the current string.

5. **contains(CharSequence sequence)**: Checks if the string contains the specified sequence of characters.

6. **endsWith(String suffix)**: Checks if the string ends with the specified suffix.

7. **equals(Object anObject)**: Compares this string to the specified object for equality.

8. **equalsIgnoreCase(String anotherString)**: Compares this string to another string, ignoring case.

9. **format(String format, Object... args)**: Returns a formatted string using the specified format string and arguments.

10. **indexOf(String str)**: Returns the index of the first occurrence of the specified substring.

11. **lastIndexOf(String str)**: Returns the index of the last occurrence of the specified substring.

12. **length()**: Returns the length of the string.

13. **replace(char oldChar, char newChar)**: Returns a new string resulting from replacing all occurrences of a specified character with a new character.

14. **replaceAll(String regex, String replacement)**: Replaces each substring that matches the given regular expression with the specified replacement.

15. **split(String regex)**: Splits the string around matches of the given regular expression.

16. **startsWith(String prefix)**: Checks if the string starts with the specified prefix.

17. **substring(int beginIndex)**: Returns a new string that is a substring of this string, starting from the specified index.

18. **substring(int beginIndex, int endIndex)**: Returns a new string that is a substring of this string, starting from the begin index and extending to the end index.

19. **toLowerCase()**: Converts all characters in the string to lowercase.

20. **toUpperCase()**: Converts all characters in the string to uppercase.

21. **trim()**: Removes leading and trailing whitespace from the string.

22. **isEmpty()**: Checks if the string is empty.

23. **valueOf(Object obj)**: Returns the string representation of the specified object.

24. **toCharArray()**: Converts the string to a new character array.

25. **join(CharSequence delimiter, CharSequence... elements)**: Joins the specified elements with the given delimiter.

26. **repeat(int count)**: Returns a string that consists of the original string repeated the specified number of times.

### Example Usage

Here's a simple example of some of these methods in action:

```java
public class StringExample {
    public static void main(String[] args) {
        String str = " Hello, World! ";

        // Length
        System.out.println("Length: " + str.length());

        // Trim
        System.out.println("Trimmed: '" + str.trim() + "'");

        // To Upper Case
        System.out.println("Uppercase: " + str.toUpperCase());

        // To Lower Case
        System.out.println("Lowercase: " + str.toLowerCase());

        // CharAt
        System.out.println("Character at index 1: " + str.charAt(1));

        // Replace
        System.out.println("Replaced: " + str.replace("World", "Java"));

        // Split
        String[] parts = str.split(", ");
        System.out.println("First part: " + parts[0]);
        System.out.println("Second part: " + parts[1]);

        // Check if contains
        System.out.println("Contains 'World': " + str.contains("World"));
    }
}
```

This list provides a good overview of the methods available in the `String` class, but it’s worth checking the [official Java documentation](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html) for a complete and up-to-date reference.

### Summary of Formatting Values in Java

Java provides methods for formatting `String` values using formatting flags, allowing for the construction of formatted strings with a single method call instead of multiple concatenations. The relevant methods include:

1. **`public static String format(String format, Object args...)`**
2. **`public static String format(Locale loc, String format, Object args...)`**
3. **`public String formatted(Object args...)`**

These methods return a reference to the calling instance, enabling method chaining. The parameters in these methods are inserted and formatted using symbols defined in a format string. Common symbols include:
- **`%s`**: for any type, commonly strings.
- **`%d`**: for integers.
- **`%f`**: for floating-point numbers.
- **`%n`**: for line breaks.

#### Example Usage
```java
var name = "Kate";
var orderId = 5;
System.out.println("Hello " + name + ", order " + orderId + " is ready");
System.out.println(String.format("Hello %s, order %d is ready", name, orderId));
System.out.println("Hello %s, order %d is ready".formatted(name, orderId));
```

Using mixed data types can lead to exceptions, such as `IllegalFormatConversionException` if the expected type does not match the provided type.

#### Using Flags
In addition to symbols, optional flags can modify the formatting:
- To control the number of decimal places, use **`%.1f`** for one decimal place instead of the default six.
- You can also specify the total length of the output. By default, empty spaces are filled with blank spaces, but they can be filled with zeros by placing a zero before the decimal.

#### Examples of Formatting with Flags
```java
var pi = 3.14159265359;
System.out.format("[%f]", pi);           // [3.141593]
System.out.format("[%12.8f]", pi);       // [  3.14159265]
System.out.format("[%012f]", pi);        // [00003.141593]
System.out.format("[%12.2f]", pi);       // [        3.14]
System.out.format("[%.3f]", pi);         // [3.142]
```

While the `format()` method supports many other symbols and flags, it’s recommended to focus only on the discussed ones for exam preparation.


###  Using the StringBuilder Class

When creating multiple `String` objects in a loop, such as the example below, many unnecessary objects are instantiated, leading to inefficiency:

```java
String alpha = "";
for (char current = 'a'; current <= 'z'; current++)
    alpha += current;
System.out.println(alpha);
```

In this code, the initial empty `String` is instantiated, and each time a character is appended, a new `String` object is created. After 26 iterations, a total of 27 `String` objects are created, most of which become eligible for garbage collection immediately. This approach is inefficient due to the immutability of `String` objects.

To address this issue, Java provides the `StringBuilder` class, which allows for the construction of `String` objects without generating interim values. Unlike `String`, `StringBuilder` is mutable:

```java
StringBuilder alpha = new StringBuilder();
for (char current = 'a'; current <= 'z'; current++)
    alpha.append(current);
System.out.println(alpha);
```

In this revised code, a single `StringBuilder` object is created, and characters are appended to it within the loop without creating new `String` objects. This reuse of the `StringBuilder` improves efficiency.

While `StringBuffer` also provides similar functionality and supports thread safety, it is not relevant for the exam and performs slower than `StringBuilder`. Thus, `StringBuilder` is the preferred choice for string manipulation in most cases. 

This section covers how to create a `StringBuilder` and use its common methods.

### Summary of Creating a StringBuilder

**Constructing a StringBuilder:**
There are three ways to create a `StringBuilder`:
1. `StringBuilder sb1 = new StringBuilder();` - Initializes an empty `StringBuilder`.
2. `StringBuilder sb2 = new StringBuilder("animal");` - Initializes a `StringBuilder` with a specific string.
3. `StringBuilder sb3 = new StringBuilder(10);` - Initializes a `StringBuilder` with a reserved capacity for characters.

**Important StringBuilder Methods:**
- **Common Methods:** Several methods in `StringBuilder` operate similarly to those in `String`, such as `substring`, `length`, and `charAt`. For example:
  ```java
  var sb = new StringBuilder("animals");
  String sub = sb.substring(sb.indexOf("a"), sb.indexOf("al")); // "anim"
  int len = sb.length(); // 7
  char ch = sb.charAt(6); // 's'
  System.out.println(sub + " " + len + " " + ch); // Output: anim 7 s
  ```

- **Appending Values:** The `append()` method adds parameters to the `StringBuilder`. It supports various data types and allows for method chaining:
  ```java
  var sb = new StringBuilder().append(1).append('c');
  sb.append("-").append(true);
  System.out.println(sb); // Output: 1c-true
  ```

- **Inserting Data:** The `insert()` method adds characters at a specified index:
  ```java
  var sb = new StringBuilder("animals");
  sb.insert(7, "-"); // animals-
  sb.insert(0, "-"); // -animals-
  sb.insert(4, "-"); // -ani-mals-
  System.out.println(sb);
  ```

- **Deleting Contents:** The `delete()` method removes characters, while `deleteCharAt()` deletes a single character:
  ```java
  var sb = new StringBuilder("abcdef");
  sb.delete(1, 3); // adef
  sb.deleteCharAt(5); // StringIndexOutOfBoundsException
  ```

- **Replacing Portions:** The `replace()` method replaces characters in a specified range:
  ```java
  var builder = new StringBuilder("pigeon dirty");
  builder.replace(3, 6, "sty"); // pigsty dirty
  ```

- **Reversing:** The `reverse()` method reverses the characters in the `StringBuilder`:
  ```java
  var sb = new StringBuilder("ABC");
  sb.reverse();
  System.out.println(sb); // Output: CBA
  ```

**Working with toString():** The `toString()` method converts a `StringBuilder` to a `String`, allowing its use in methods that require a `String` input:
```java
var sb = new StringBuilder("ABC");
String s = sb.toString();
```

### Summary of Comparing `equals()` and `==` in Java

#### Understanding `==` with Objects
- When using `==` with object references, it checks if two references point to the same object in memory.
- Example:
  ```java
  var one = new StringBuilder();
  var two = new StringBuilder();
  var three = one.append("a");
  System.out.println(one == two);   // false
  System.out.println(one == three); // true
  ```
  - `one` and `two` are different `StringBuilder` instances, so the first comparison is false.
  - `three` is a reference to the same object as `one` after the append operation, making the second comparison true.

#### The `equals()` Method
- Unlike the `==` operator, the `equals()` method checks for logical equality (value equality).
- For `String` objects:
  ```java
  var x = "Hello World";
  var z = " Hello World".trim();
  System.out.println(x.equals(z)); // true
  ```
- The `StringBuilder` class does not override the `equals()` method, so it behaves like `==`, checking reference equality. Use `toString()` to compare values.

#### Compilation Errors with Different Types
- Comparing a `String` and a `StringBuilder` with `==` will result in a compilation error:
  ```java
  var name = "a";
  var builder = new StringBuilder("a");
  System.out.println(name == builder);  // DOES NOT COMPILE
  ```

#### The String Pool
- Java uses a string pool to optimize memory usage by reusing common string literals.
- Example:
  ```java
  var x = "Hello World";
  var y = "Hello World";
  System.out.println(x == y); // true
  ```
  - Both `x` and `y` point to the same memory location in the pool.

#### Runtime String Creation
- When creating strings at runtime (not compile-time constants), new `String` objects are created:
  ```java
  var x = "Hello World";
  var z = " Hello World".trim();
  System.out.println(x == z); // false
  ```

#### Using `+=` with Strings
- Using `+=` creates a new `String` object:
  ```java
  var singleString = "hello world";
  var concat = "hello ";
  concat += "world";
  System.out.println(singleString == concat); // false
  ```

#### Creating New Strings with `new`
- Using `new` explicitly creates a new string:
  ```java
  var x = "Hello World";
  var y = new String("Hello World");
  System.out.println(x == y); // false
  ```

#### Interning Strings
- The `intern()` method can be used to add a string to the string pool or retrieve it if it already exists:
  ```java
  var name = "Hello World";
  var name2 = new String("Hello World").intern();
  System.out.println(name == name2); // true
  ```

#### Examples with Compile-Time Constants
- Comparing compile-time constants:
  ```java
  var first = "rat" + 1; // "rat1"
  var second = "r" + "a" + "t" + "1"; // "rat1"
  var third = "r" + "a" + "t" + new String("1"); // "rat1" (not a compile-time constant)
  ```
  - Line comparisons:
    - `first == second` and `first == second.intern()` will be true.
    - `first == third` will be false because `third` is not a compile-time constant.
    - `first == third.intern()` will be true, as `intern()` retrieves the reference from the pool.

### Conclusion
- Avoid using `intern()` or `==` for string comparison in practice. Use `equals()` for logical equality checks on `String` objects. The above details are primarily for exam preparation.

### The String Pool

In Java, strings are heavily used and can consume a lot of memory. To address this, Java uses a "string pool," which is a section in the Java Virtual Machine (JVM) where commonly used string literals are stored and reused, reducing memory consumption. 

The **string pool** holds string literals and constant values that appear in your program, while strings created dynamically (e.g., through methods like `myObject.toString()`) do not automatically go into the pool. When a string literal is used multiple times, Java only creates one instance in memory, and all references to that literal point to the same memory location.

### Example: String Equality

Consider this code:
```java
var x = "Hello World";
var y = "Hello World";
System.out.println(x == y); // true
```
Both `x` and `y` refer to the same string literal, and since Java pools literals, they point to the same memory location. Therefore, `x == y` is `true` because they refer to the same object in the string pool.

However, this scenario is different:
```java
var x = "Hello World";
var z = " Hello World".trim();
System.out.println(x == z); // false
```
Here, `x` is a literal pooled at compile-time, but `z` is computed at runtime. Since `trim()` creates a new string, it is not pooled, and `x == z` is `false`.

### String Concatenation and New Objects

String concatenation also creates new objects:
```java
var singleString = "hello world";
var concat = "hello ";
concat += "world";
System.out.println(singleString == concat); // false
```
The `+=` operator results in a new string being created, so `singleString` and `concat` refer to different objects, even though their content is the same.

Additionally, creating a new string explicitly with `new String()` bypasses the pool:
```java
var x = "Hello World";
var y = new String("Hello World");
System.out.println(x == y); // false
```
The `new String()` creates a new object in memory, so `x == y` is `false` even though both contain the same string.

### The `intern()` Method

Java allows you to manually add strings to the pool using the `intern()` method:
```java
var name = "Hello World";
var name2 = new String("Hello World").intern();
System.out.println(name == name2); // true
```
Here, `name2` is a new string but is "interned" to the pool, which forces it to use the same memory reference as `name`, making `name == name2` true.

### Example: Complex String Pooling Scenario

```java
var first = "rat" + 1;
var second = "r" + "a" + "t" + "1";
var third = "r" + "a" + "t" + new String("1");
System.out.println(first == second);          // true
System.out.println(first == second.intern()); // true
System.out.println(first == third);           // false
System.out.println(first == third.intern());  // true
```
- Lines 15-16: `first` and `second` are compile-time constants, so both are placed in the pool, making `first == second` true.
- Line 17: `third` uses a `new String()`, so it isn't pooled. Thus, `first == third` is false.
- Line 21: Using `intern()` forces `third` into the pool, so `first == third.intern()` is true.

### Key Takeaways:
- **String literals** are stored in the string pool, ensuring that identical literals refer to the same memory location.
- Strings created at runtime (e.g., through concatenation or methods like `trim()`) are not automatically pooled.
- Using `new String()` explicitly creates a new object and bypasses the pool.
- You can use the `intern()` method to add a string to the pool manually.
- **Avoid using `==` to compare strings**; use `equals()` instead, except in cases like exam questions that test this specific behavior.

## Understanding Arrays in Java

Arrays in Java are used to store multiple elements of the same type in a fixed-size, ordered list. They can hold both primitive data types (like `int`, `char`) and objects. Key points include:

- **Arrays are fixed in size**: Once created, their size cannot be changed.
- **Default values**: Elements are initialized to default values (e.g., `0` for `int`, `null` for objects).
- **Array creation**: Arrays can be created with default values or initialized with specific elements.
  - Example: `int[] numbers = new int[3];` or `int[] numbers = {42, 55, 99};`
- **Syntax flexibility**: Brackets can be placed before or after the variable name, but consistent syntax is recommended for readability.
- **Multiple declarations**: When declaring multiple variables, care must be taken as `int[] ids, types;` creates two arrays, but `int ids[], types;` creates one array and one `int`.

Arrays provide the foundation for working with sequences of elements and are essential for efficient memory management in Java programs.


### Creating and Using Arrays with Reference Variables

### Creating and Using Arrays with Reference Variables

- Arrays can hold any Java type, including custom classes and primitives.  
  Example:  
  ```java
  String[] bugs = { "cricket", "beetle", "ladybug" };
  String[] alias = bugs;
  ```

- The `equals()` method on arrays checks **reference equality**, not the array elements.
  ```java
  System.out.println(bugs.equals(alias)); // true
  ```

- Arrays store **references** to objects, not the objects themselves.  
  Example:  
  ```java
  String[] names = new String[2]; // references pointing to null
  ```

- Assigning a broader type (e.g., `Object[]`) to a more specific type (e.g., `String[]`) can lead to `ArrayStoreException` at runtime.  
  Example:  
  ```java
  Object[] objects = new String[1];
  objects[0] = new StringBuilder(); // Throws ArrayStoreException at runtime
  ```

- The `length` attribute counts the allocated array elements, starting at index 0.
  ```java
  String[] mammals = {"monkey", "chimp", "donkey"};
  System.out.println(mammals.length); // 3
  ```

- Accessing **invalid indexes** throws `ArrayIndexOutOfBoundsException`.  
  Example:  
  ```java
  int[] numbers = new int[10];
  numbers[10] = 3; // Exception: index out of bounds
  ```

- Loops are commonly used to iterate through arrays, and mistakes in index bounds often cause errors.  
  Example:  
  ```java
  for (int i = 0; i <= numbers.length; i++) { // Incorrect (should be <)
      numbers[i] = i + 5;  // ArrayIndexOutOfBoundsException
  }
  ```

### Sorting, Searching, Comparing Arrays in Java

#### Sorting Arrays
Java provides an easy way to sort arrays using the `Arrays.sort()` method, which can handle various types of arrays.

To use `Arrays.sort()`, import the package:
```java
import java.util.Arrays; // Import only Arrays
```
Here's a simple example that sorts an array of integers:
```java
int[] numbers = { 6, 9, 1 };
Arrays.sort(numbers);
for (int i = 0; i < numbers.length; i++) {
    System.out.print(numbers[i] + " ");
}
// Output: 1 6 9
```
You can also print the array in a single line using `Arrays.toString()`:
```java
System.out.println(Arrays.toString(numbers)); // Output: [1, 6, 9]
```

For strings:
```java
String[] strings = { "10", "9", "100" };
Arrays.sort(strings);
for (String s : strings) {
    System.out.print(s + " ");
}
// Output: 10 100 9
```
Strings are sorted alphabetically, which is why "10" comes before "9".

#### Searching Arrays
Java allows searching in arrays using `Arrays.binarySearch()`, but the array must be sorted first.

Here are the rules for binary search:
- If the target is found, it returns the index.
- If not found, it returns a negative value indicating where the element would be inserted.
- If the array is unsorted, the result is undefined.

Example:
```java
int[] numbers = { 2, 4, 6, 8 }; // Sorted array
System.out.println(Arrays.binarySearch(numbers, 2)); // 0
System.out.println(Arrays.binarySearch(numbers, 4)); // 1
System.out.println(Arrays.binarySearch(numbers, 1)); // -1
System.out.println(Arrays.binarySearch(numbers, 3)); // -2
System.out.println(Arrays.binarySearch(numbers, 9)); // -5
```
In this example, line 5 shows how the search can find where to insert a new element.

If the array is unsorted:
```java
int[] numbers = new int[] { 3, 2, 1 };
System.out.println(Arrays.binarySearch(numbers, 2)); // Output can be unpredictable
System.out.println(Arrays.binarySearch(numbers, 3)); // Output can be unpredictable
```

#### Comparing Arrays
You can compare two arrays using `Arrays.compare()`, which indicates which array is "smaller" based on specific rules:

- A negative number means the first array is smaller.
- A zero means the arrays are equal.
- A positive number means the first array is larger.

Example:
```java
System.out.println(Arrays.compare(new int[] { 1 }, new int[] { 2 })); // Negative number
```

Comparison rules include:
- Length matters: longer arrays that are equal up to the shorter array are considered larger.
- Numeric order applies to numbers, while null is considered smaller than any value.

#### Using Mismatch
The `Arrays.mismatch()` method checks for differences:
- Returns -1 if arrays are equal.
- Returns the first index where they differ.

Example:
```java
System.out.println(Arrays.mismatch(new int[] { 1 }, new int[] { 1 })); // -1
System.out.println(Arrays.mismatch(new String[] { "a" }, new String[] { "A" })); // 0
System.out.println(Arrays.mismatch(new int[] { 1, 2 }, new int[] { 1 })); // 1
```

#### Using Methods with Varargs
You can define methods using varargs, allowing you to pass a variable number of arguments. It behaves like an array:
```java
public static void main(String... args) {
    System.out.println(args.length); // Legal
    System.out.println(args[0]); // Legal
}
```
Varargs can simplify method calls while still using array functionality.


Here's a summary of the key points from the text about multidimensional arrays in Java:

### Multidimensional Arrays
- **Definition**: Arrays in Java can hold other arrays, leading to the concept of multidimensional arrays.
- **Declaration**:
  - You can declare a two-dimensional (2D) array using various syntaxes, such as:
    ```java
    int[][] vars1;          // 2D array
    int vars2 [][];         // 2D array
    int[] vars3[];          // 2D array
    int[] vars4[], space [][];  // 2D and 3D array
    ```
  - A single line can declare both a 2D and a 3D array.

#### Creating Multidimensional Arrays
- **Size Specification**: You can specify sizes during declaration:
  ```java
  String[][] rectangle = new String[3][2];
  ```
  This creates a 3x2 array. For example, setting a value:
  ```java
  rectangle[0][1] = "set";
  ```
- **Sparsely Populated Arrays**: An array may have many null values when not fully populated.

#### Asymmetric Multidimensional Arrays
- Arrays do not need to be rectangular. You can create them with different sizes for inner arrays:
  ```java
  int[][] differentSizes = {{1, 4}, {3}, {9, 8, 7}};
  ```
- Another way to create an asymmetric array is to initialize the first dimension and define sizes later:
  ```java
  int[][] args = new int[4][];
  args[0] = new int[5];
  args[1] = new int[3];
  ```

#### Using Multidimensional Arrays
- **Looping through Arrays**: Common operations include looping through multidimensional arrays to access their elements. For example:
  ```java
  var twoD = new int[3][2];
  for (int i = 0; i < twoD.length; i++) {
      for (int j = 0; j < twoD[i].length; j++)
          System.out.print(twoD[i][j] + " "); // print element
      System.out.println();                  // new row
  }
  ```
- **Enhanced For Loop**: A more readable way to loop through arrays:
  ```java
  for (int[] inner : twoD) {
      for (int num : inner)
          System.out.print(num + " ");
      System.out.println();
  }
  ```

This summary captures the essence of working with multidimensional arrays in Java, including their declaration, creation, and common operations. If you have any specific areas you'd like to explore further or need examples for, let me know!


Here's a summary of the key concepts about calculating with Math APIs in Java:

## Java Math Class
- **Purpose**: The `Math` class provides various methods for mathematical operations, making it easier to perform calculations.

### Common Methods

1. **Finding Minimum and Maximum**
   - Methods: 
     - `public static double min(double a, double b)`
     - `public static float min(float a, float b)`
     - `public static int min(int a, int b)`
     - `public static long min(long a, long b)`
   - Usage:
     ```java
     int first = Math.max(3, 7);   // Returns 7
     int second = Math.min(7, -9); // Returns -9
     ```

2. **Rounding Numbers**
   - Methods: 
     - `public static long round(double num)`
     - `public static int round(float num)`
   - Usage:
     ```java
     long low = Math.round(123.45);       // Returns 123
     long high = Math.round(123.50);      // Returns 124
     int fromFloat = Math.round(123.45f); // Returns 123
     ```

3. **Determining the Ceiling and Floor**
   - Methods:
     - `public static double ceil(double num)`
     - `public static double floor(double num)`
   - Usage:
     ```java
     double c = Math.ceil(3.14);  // Returns 4.0
     double f = Math.floor(3.14); // Returns 3.0
     ```

4. **Calculating Exponents**
   - Method:
     - `public static double pow(double number, double exponent)`
   - Usage:
     ```java
     double squared = Math.pow(5, 2); // Returns 25.0
     ```

5. **Generating Random Numbers**
   - Method:
     - `public static double random()`
   - Usage:
     ```java
     double num = Math.random(); // Returns a value >= 0 and < 1
     ```

### Important Notes
- **Return Types**: Be cautious about return types, especially with rounding and exponent methods, as they can return different types (e.g., `double` vs. `int`).
- **Random Class**: Although not covered in the exam, the `Random` class is often used for generating pseudo-random numbers and allows generating various types of random values.

This summary captures the key functionalities of the Math class in Java, focusing on the most commonly used methods and their applications. If you have specific questions or need further examples, feel free to ask!


Here's a summary of the information you provided about working with dates and times in Java, highlighting the key points for easier recall:

## Working with Dates and Times in Java

4 choices 

- **LocalDate**: Represents a date without time or time zone (e.g., your birthday this year).
- **LocalTime**: Represents a time without date or time zone (e.g., midnight).
- **LocalDateTime**: Represents both date and time but no time zone (e.g., midnight on New Year's Eve).
- **ZonedDateTime**: Represents date, time, and time zone (e.g., a conference call at 9:00 a.m. EST, which is 6:00 a.m. in California).

<mark style="background: #FF5582A6;">keys info : zoned time, time, date</mark>


### Method in LocalDate, LoacalTime, LocalDateTime, ZonedDateTime

Here's the information organized into a table format:

| **Method**       | **Description**                                | **Signature**                                           | **Can call on LocalDate?** | **Can call on LocalTime?** | **Can call on LocalDateTime/ZonedDateTime?** |
| ---------------- | ---------------------------------------------- | ------------------------------------------------------- | -------------------------- | -------------------------- | -------------------------------------------- |
| `plusYears()`    | Adds the specified number of years.            | `public LocalDate plusYears(long yearsToAdd)`           | Yes                        | No                         | Yes                                          |
| `minusYears()`   | Subtracts the specified number of years.       | `public LocalDate minusYears(long yearsToSubtract)`     | Yes                        | No                         | Yes                                          |
| `plusMonths()`   | Adds the specified number of months.           | `public LocalDate plusMonths(long monthsToAdd)`         | Yes                        | No                         | Yes                                          |
| `minusMonths()`  | Subtracts the specified number of months.      | `public LocalDate minusMonths(long monthsToSubtract)`   | Yes                        | No                         | Yes                                          |
| `plusWeeks()`    | Adds the specified number of weeks.            | `public LocalDate plusWeeks(long weeksToAdd)`           | Yes                        | No                         | Yes                                          |
| `minusWeeks()`   | Subtracts the specified number of weeks.       | `public LocalDate minusWeeks(long weeksToSubtract)`     | Yes                        | No                         | Yes                                          |
| `plusDays()`     | Adds the specified number of days.             | `public LocalDate plusDays(long daysToAdd)`             | Yes                        | No                         | Yes                                          |
| `minusDays()`    | Subtracts the specified number of days.        | `public LocalDate minusDays(long daysToSubtract)`       | Yes                        | No                         | Yes                                          |
| `plusHours()`    | Adds the specified number of hours.            | `public LocalTime plusHours(long hoursToAdd)`           | No                         | Yes                        | Yes                                          |
| `minusHours()`   | Subtracts the specified number of hours.       | `public LocalTime minusHours(long hoursToSubtract)`     | No                         | Yes                        | Yes                                          |
| `plusMinutes()`  | Adds the specified number of minutes.          | `public LocalTime plusMinutes(long minutesToAdd)`       | No                         | Yes                        | Yes                                          |
| `minusMinutes()` | Subtracts the specified number of minutes.     | `public LocalTime minusMinutes(long minutesToSubtract)` | No                         | Yes                        | Yes                                          |
| `plusSeconds()`  | Adds the specified number of seconds.          | `public LocalTime plusSeconds(long secondsToAdd)`       | No                         | Yes                        | Yes                                          |
| `minusSeconds()` | Subtracts the specified number of seconds.     | `public LocalTime minusSeconds(long secondsToSubtract)` | No                         | Yes                        | Yes                                          |
| `plusNanos()`    | Adds the specified number of nanoseconds.      | `public LocalTime plusNanos(long nanosToAdd)`           | No                         | Yes                        | Yes                                          |
| `minusNanos()`   | Subtracts the specified number of nanoseconds. | `public LocalTime minusNanos(long nanosToSubtract)`     | No                         | Yes                        | Yes                                          |

This table clearly shows which methods can be called on `LocalDate`, `LocalTime`, and `LocalDateTime`/`ZonedDateTime`, along with their descriptions and method signatures

### Working with periods

<mark style="background: #FF5582A6;">In Java, a `Period` represents a quantity of time in terms of years, months, and days, used for date-based calculations.</mark>



```java
public static void main(String[] args) {
   // Create a start date of January 1, 2022
   var start = LocalDate.of(2022, Month.JANUARY, 1);
   
   // Create an end date of March 30, 2022
   var end = LocalDate.of(2022, Month.MARCH, 30);
   
   // Call the method to perform animal enrichment activities between the start and end dates
   performAnimalEnrichment(start, end);
}

private static void performAnimalEnrichment(LocalDate start, LocalDate end) {
   // Initialize a variable to track the current date, starting from 'start'
   var upTo = start;
   
   // Loop until 'upTo' reaches or surpasses the 'end' date
   while (upTo.isBefore(end)) { // check if still before end
      // Print a message indicating that a new toy is given on the current date
      System.out.println("give new toy: " + upTo);
      
      // Increment the 'upTo' date by one month
      upTo = upTo.plusMonths(1); // add a month
   }
}
```

- The code work fine ✅
- But it' can't be reused (we want to use different schedule to see whaich work best)❌


> `LocalDate` and `LocalDateTime` have a method to convert themselves into `long` values, equivalent to the number of milliseconds that have passed since January 1, 1970, referred to as the _epoch_. What's special about this date? That's what Unix started using for date standards, so Java reused it.


5 ways to use periods 🔁

```java
var annually = Period.ofYears(1);            // every 1 year
var quarterly = Period.ofMonths(3);          // every 3 months
var everyThreeWeeks = Period.ofWeeks(3);     // every 3 weeks
var everyOtherDay = Period.ofDays(2);        // every 2 days
var everyYearAndAWeek = Period.of(1, 0, 7);  // every year and 7 days
```
![[Pasted image 20241117044542.png]]

example : 

```java
import java.time.*;

public class MyClass {
  public static void main(String args[]) {
             System.out.println(Period.ofMonths(3)); // output : P3M
  }
}
```

### Working with Duration

- In Java, `Duration` represents a time-based amount measured in hours, minutes, seconds, and nanoseconds, useful for calculating time intervals between two points in time.
- The main difference is that `Duration` measures time-based amounts in hours, minutes, seconds, and nanoseconds, while `Period` represents date-based amounts in years, months, and days.


```java
var daily = Duration.ofDays(1);               // PT24H
var hourly = Duration.ofHours(1);             // PT1H
var everyMinute = Duration.ofMinutes(1);      // PT1M
var everyTenSeconds = Duration.ofSeconds(10); // PT10S
var everyMilli = Duration.ofMillis(1);        // PT0.001S
var everyNano = Duration.ofNanos(1);          // PT0.000000001S
```


`ris:ArrowDown``ris:ArrowDown``ris:ArrowDown``ris:ArrowDown`


```java
var daily = Duration.of(1, ChronoUnit.DAYS);
var hourly = Duration.of(1, ChronoUnit.HOURS);
var everyMinute = Duration.of(1, ChronoUnit.MINUTES);
var everyTenSeconds = Duration.of(10, ChronoUnit.SECONDS);
var everyMilli = Duration.of(1, ChronoUnit.MILLIS);
var everyNano = Duration.of(1, ChronoUnit.NANOS);
```

`ChronoUnit` also includes some convenient units such as `ChronoUnit.HALF_DAYS` to represent 12 hours. 💡

<u>Truncation ex</u>

```java
    LocalTime time = LocalTime.of(3,12,45);
    System.out.println(time);      // 03:12:45
    LocalTime truncated = time.truncatedTo(ChronoUnit.MINUTES);
    System.out.println(truncated); // 03:12
    //conversion 3:12:45   ==>   3:12
```


| **Type**        | **Can use with Period?** | **Can use with Duration?** |
| --------------- | ------------------------ | -------------------------- |
| `LocalDate`     | Yes                      | No                         |
| `LocalDateTime` | Yes                      | Yes                        |
| `LocalTime`     | No                       | Yes                        |
| `ZonedDateTime` | Yes                      | Yes                        |

### Working with Instants

- In Java, `Instant` is a class from the `java.time` package that represents a specific moment on the timeline in UTC (Coordinated Universal Time), typically used for timestamps or precise time measurements down to the nanosecond.

```java
var now = Instant.now();
// do something time consuming
var later = Instant.now();
 
var duration = Duration.between(now, later);
System.out.println(duration.toMillis());  // Returns number milliseconds
```

### Summary in Bullet Points:

- **String**:
  - Immutable sequence of characters.
  - Explicitly calling the constructor is optional.
  - Concatenation operator (`+`) creates a new `String`.
  - If either operand is a `String`, concatenation is used; otherwise, addition occurs.
  - String literals are stored in the string pool.
  - Many methods are provided by the `String` class.

- **StringBuilder**:
  - Mutable sequence of characters.
  - Methods return a reference to the current object, allowing method chaining.
  - Includes various methods for string manipulation.

- **Comparison of `String` and `StringBuilder`**:
  - `==` checks if two `String` objects point to the same object in the pool.
  - `==` for `StringBuilder` checks if references point to the same `StringBuilder` object.
  - `equals()` on `String` checks character sequence equality.
  - `equals()` on `StringBuilder` checks if the references point to the same object.

- **Arrays**:
  - Fixed-size memory allocation on the heap for primitives or object references.
  - Size is specified upon creation (e.g., `int[] a = new int[6];`).
  - Indexes start at 0, and elements are accessed using `[index]`.
  - `Arrays.sort()` sorts an array.
  - `Arrays.binarySearch()` searches a sorted array and returns the index of a match or a negated insertion position.
  - `Arrays.compare()` and `Arrays.mismatch()` check array equivalency.
  - Varargs (`...`) can be passed as arrays.
  - Multidimensional arrays can have second-level arrays of different sizes.

- **Math Class**:
  - Provides static methods for mathematical operations (e.g., min, max, round, random number generation).
  - Works with numeric primitives, with some methods specific to `double`.

- **Date and Time Classes**:
  - `LocalDate` holds only a date.
  - `LocalTime` holds only a time.
  - `LocalDateTime` holds both a date and time.
  - Created using `LocalDate.now()` or `LocalDate.of()`, and similar methods for other classes.
  - Dates and times can be manipulated using `plusXXX` or `minusXXX` methods.
  - `Period` class represents days, months, or years to add/subtract from `LocalDate` or `LocalDateTime`.
  - All date and time classes are immutable; return values must be used.
